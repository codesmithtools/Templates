<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head>
<title>CodeSmith Linq to Sql Templates</title>
<style type="text/css">
.style1 {
	color: #FF0000;
}
</style>
</head>

<body>

<h1>Table of Contents</h1>
<ul>
	<li><a href="#Overview">Overview</a></li>
	<li><a href="#Features">Features</a></li>
	<li><a href="#QuickStart">Quick Start</a></li>
	<li><a href="#DoItYourself">Do It Yourself</a></li>
	<li><a href="#Dbml.cst">Dbml.cst Template</a></li>
	<li><a href="#QuickStart.cst">QuickStart.cst Template</a></li>
	<li><a href="#Entities.cst">Entities.cst Template</a></li>
	<li><a href="#Managers.cst">Managers.cst Template</a></li>
	<li><a href="#Queries.cst_Template">Queries.cst Template</a></li>
	<li><a href="#Global.cst_Template">Global.cst Template</a></li>
	<li><a href="#KnownIssues">Known Issues</a></li>
	<li><a href="#Roadmap">Roadmap</a></li>
	<li><a href="#Download">Download</a></li>
</ul>
<h2><a title="Overview" name="Overview"></a>Overview</h2>

<p>PLINQO, which stands for Professional LINQ to Objects, is a collection of CodeSmith 
templates that are meant to replace and extend the LINQ to SQL designers that are 
included with Visual Studio.</p>

<p>Go learn more about Plinqo even faster, please check out our Video Tutorials!<br>
<a href="http://codesmithtools.com/video/plinqo-part-1-quick-start.html">Plinqo Part 1: The Quick Start</a><br>
<a href="http://codesmithtools.com/video/plinqo-part-2-feature-overview.html">Plinqo Part 2: Feature Overview</a></p>

<h2><a title="Features" name="Features">Features</a></h2>
<p>The templates have the following features.</p>
<ul>
	<li>Generate or update a LINQ to SQL dbml file from a database schema.<ul>
		<li>Includes all tables, stored procedures, functions, and views with the 
		ability to exclude objects based on regex patterns.</li>
		<li>Ability to automatically remove object prefix and suffixes (ie. tbl_ 
		and usp_).</li>
		<li>Ability to standardize object names produced from database tables.</li>
		<li>Dbml file can still be customized with the normal Visual Studio 
		designer.</li>
		<li>Dbml file can be refreshed based on the current database schema without 
		losing customizations. <em>(See Safe Attributes)</em></li>
	</ul>
	</li>
	<li>Generation of the LINQ to SQL DataContext class.</li>
	<li>Generation of the LINQ to SQL entity classes.<ul>
		<li>Generates one file per entity instead of one massive file.</li>
		<li>Generates partial classes where custom code can be written and won&#39;t 
		be overwritten.</li>
		<li>Generates Metadata classes with attribute tags from DBML information.</li>
		<li>Generated entity files are added to the project as code behind files 
		to their corresponding custom entity files.</li>
	</ul>
	</li>
	<li>Generation of entity manager classes.<ul>
		<li>Adds customizable business rules engine to enforce entity validation, 
		business and security rules based on metadata tags.</li>
		<li>Provides access to common queries based on primary keys, foreign keys, 
		and indexes.</li>
		<li>Common queries are exposed as IQueryable so they can be extended.</li>
	</ul>
	</li>
	<li>Generation of query extension methods.</li>
	<li>Generation of global.asax file for dynamic data.</li>
	<li>All templates can be customized to meet your needs.</li>
</ul>
<h2>Advantages Over Designer</h2>
<p><font class="messagecontent">There are several advantages to using the PLINQO 
templates over the Visual Studio designer. Here is a list of the main reasons:</font></p>
<ol>
	<li><font class="messagecontent">Remove the designer black box and allow for 
	customization of the output while still retaining the ability to use the .dbml 
	designer to make customizations inside of Visual Studio.</font></li>
	<li><font class="messagecontent">Ability to easily generate your entire .dbml 
	file for a database and then the ability to regenerate that .dbml file as 
	the schema changes. The regeneration preserves any customizations you may 
	have made such as entity, property and relationship names. With the 
	designer, if you make a database change, you need to drop the entity and 
	re-add it to get any new columns or data type changes, which would cause you 
	to lose any customizations you may have made. Also, using the templates 
	allows you to exclude unwanted tables, stored procedures and views using 
	filter expressions and automatically strip / clean entity and property names 
	of things like prefixes and suffixes that your database schema may be using 
	(ie. tbl_Customer to Customer).</font></li>
	<li><font class="messagecontent">A business rules engine that allows you to 
	enforce things like property length rules, required field rules, regex data 
	validation rules as well as several other built in rules including 
	authorization rules using metadata attributes. The SubmitChanges method on
	the data context object will automatically run the rules against any
	entities in your change set. If all rules are not met, a BrokenRulesException
	will be thrown that contains a list of the broken rules.</font></li>
	<li><font class="messagecontent">A manager class is generated for each 
	entity that encapsulates all actions taken on an entity. Known common 
	actions like retrieving entities by primary key, indexes, and foreign keys 
	are generated. Any custom actions can be added and will be preserved during 
	regeneration. While LINQ makes it easy to sprinkle your data access logic 
	throughout your entire application, we still believe its poor design to do 
	so and that is why we have included the manager classes. </font></li>
</ol>
<h2><a title="QuickStart" name="QuickStart">Quick Start</a></h2>
<p>The following steps will create a quick data driven site.</p>
<ol>
    <li>Open the QuickStart.cst file found in the directory with this file.</li>
    <li>Select your Datasource.</li>
    <li>Generate the template.</li>
    <li>After Visual Studio Opens, set [DataSource].UI as the startup project.</li>
    <li>Run the project.(F5)</li>
    <li>This produces a functional website using Dynamic Data, Data Services, and Linq to Sql.</li>
    <li>The included csp in the data project can be used to regenerate databse informatin when
        future changes are made.</li>
    <li>The quickstart has various properties that can be manipulalted in order to 
        produce differing base projects, including Language and ProjectType.</li>
</ol>

<h2><a title="DoItYourself" name="DoItYourself">Do It Yourself</a></h2>
<p>Use the following steps to get started using the Linq to Sql templates.</p>
<ol>
	<li>Create a new Class Library project in Visual Studio.</li>
	<li>Add a new CodeSmith project file to the Visual Studio project.<br />
	</li>
	<li>Add a new Output to the project file for the
	<a href="#Dbml.cst">Dbml.cst</a> template.<br />
	</li>
	<li>Add another Output to the project file for the
	<a href="#Entities.cst">Entities.cst</a> template.<br />
	</li>
	<li>Optionally, Add an Output for the
	<a href="#Managers.cst">Managers.cst</a> template.<br />
	</li>
	<li>Set the <i>Sample.csp -&gt; Output Options -&gt; Add Outputs</i> to Project to 
	unchecked.&nbsp; The templates update the project for you.</li>
	<li>Finally, Generate the Outputs. (Figure 5)<br />
	</li>
</ol>
<h2><a title="QuickStart.cst" name="QuickStart.cst">QuickStart.cst Template</a></h2>
<p>The QuickStart.cst temlplate is used to create a basic project using Linq to Sql. 
&nbsp; The template will create a visual studio solution with up to three included projects: 
&nbsp; A Data Project, an Interface Project, and a Test Project.
</p>
<p>Properties on the QuickStart.cst template:</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The Database that will be accessed by the website.</td>
	</tr>
	<tr>
		<td>Language</td>
		<td>The language that thee project will be generated in.</td>
	</tr>
	<tr>
		<td>LaunchVisualStudio</td>
		<td>Should visual studio launch when the project finishes generating.</td>
	</tr>
	<tr>
		<td>Location</td>
		<td>The root directory of the generated solution.</td>
	</tr>
	<tr>
		<td>SolutionName</td>
		<td>The name of the Visual Studio Solution.</td>		
	</tr>
	<tr>
		<td>VisualStudioVersion</td>
		<td>The version of Visual Studio you will be using.</td>
	</tr>
	<tr>
		<td>CopyTemplatesToFolder</td>
		<td>Create a copy of the Linq to Sql Directory and its contents to the data project directory.</td>
	</tr>
	<tr>
		<td>DataProjectName</td>
		<td>The name of the data project directory and project.</td>
	</tr>
	<tr>
		<td>IncludeDataServices</td>
		<td>Include Data Service Files and References in the interface project.</td>
	</tr>
	<tr>
		<td>InterfaceProjectName</td>
		<td>The name of the interface project directory and project.</td>
	</tr>
	<tr>
		<td>ProjectType</td>
		<td>The type of interface project to be created. Can be none.</td>
	</tr>
	<tr>
		<td>IncludeTestProject</td>
		<td>Include a test project in the solution.</td>
	</tr>
	<tr>
		<td>TestProjectName</td>
		<td>The name of the test project directory and project.</td>
	</tr>
</table>	
<h2><a title="Dbml.cst" name="Dbml.cst">Dbml.cst Template</a></h2>
<p>The Dbml.cst template is used to create a LINQ to SQL dbml file.&nbsp; The file 
conforms to the Microsoft DbmlSchema.xsd schema.&nbsp; This is the same document 
that the LINQ to SQL designer uses.&nbsp; The generated dbml file from this template 
can also be edited from the LINQ to SQL designer.&nbsp; </p>
<p>The template will create a new file if it doesn&#39;t exist.&nbsp; If the file does 
exist, the template will read it in and update it.&nbsp; This allows you to make 
changes to the file and not have it overwrite if the template is re-ran.&nbsp; However, 
only some of the attributes are safe from overwriting.&nbsp; Here is a list of safe 
attributes.&nbsp; They will be listed as an xpath.</p>
<p>Safe Attributes to change in the Dbml file ...</p>
<ul>
	<li>Database/@Class - The name of the DataContext class that will be generated.</li>
	<li>Database/@EntityNamespace - The namespace for the entity classes.</li>
	<li>Database/@ContextNamespace - The namespace for the DataContext class.</li>
	<li>Table/@Member - The property name for the table in the DataContext class.</li>
	<li>Type/@Name - The name of the entity class.</li>
	<li>Column/@Member - The property name for the column in the entity class.</li>
	<li>Column/@Storage - The private field LINQ to SQL will us to assign values 
	to.</li>
	<li>Association/@Member - The property name for this association.</li>
	<li>Association/@Storage - The private field LINQ to SQL will us to assign values 
	the association to.</li>
    <li>Association/@DeleteOnNull - Deletes row when association is set to null. 
    Value will not be persisted if the CST's IncludeDeleteOnNull Property is set to false.</li>
	<li>Function/@Method - The name of the method for the database procedure.</li>
	<li>Parameter/@Parameter - The method argument name that maps to the database 
	procedure parameter.</li>
</ul>
<p><b>Warning:</b> Be aware that the template will drop tables, columns and associations 
that it did not find in the database.</p>
<p>Properties on the Dbml.cst template:</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>CleanExpression</td>
		<td>List of regular expressions to clean table, view, column and procedure 
		names.&nbsp; Any matched text found will be removed from the name.</td>
	</tr>
    <tr>
		<td>EnumList</td>
		<td>List of regular expressions to identify an Enum Table.</td>
	</tr>
	<tr>
		<td>IgnoreList</td>
		<td>List of regular expressions used to ignore tables, views and procedures 
		when generating mapping.</td>
	</tr>
	<tr>
		<td>IncludeFunctions</td>
		<td>Include stored procedures and user functions in mapping.</td>
	</tr>
	<tr>
		<td>IncludeViews</td>
		<td>Include views in mapping.</td>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to generate the dbml file for.</td>
	</tr>
	<tr>
		<td>ContextNamespace</td>
		<td>The namespace to use for the context class file.</td>
	</tr>
    <tr>
		<td>EntityBase</td>
		<td>The base class for the entity.</td>
	</tr>
	<tr>
		<td>EntityNamespace</td>
		<td>The namespace to use for the entity class files.</td>
	</tr>
    <tr>
		<td>IncludeDeleteOnNull</td>
		<td>Templates will generated DeleteOnNull Attribute for Associations.</td>
	</tr>
	<tr>
		<td>Naming Conventions</td>
		<td>A Menu of options for naming objects in the dbml.</td>
	</tr>
	<tr>
		<td>AssociationNaming</td>
		<td>Add a list suffix or pluralize associations to an object.</td>
	</tr>
	<tr>
		<td>EntityNaming</td>
		<td>Generate entity objects in singular or plural form. </td>
	</tr>
	<tr>
		<td>TableNaming</td>
		<td>The table naming convention followed in the source database.</td>
	</tr>
    <tr>
		<td>NameColumn</td>
		<td>List of regular expressions to identify an Enum Table's Name Column.</td>
	</tr>
    <tr>
		<td>DescriptionColumm</td>
		<td>List of regular expressions to identify an Enum Table's Description Column.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file to generate.</td>
	</tr>
</table>
<h2><a title="Entities.cst" name="Entities.cst">Entities.cst Template</a></h2>
<p>The entities template generates the entity classes needed by LINQ.&nbsp; The 
classes are generated from a dbml file.&nbsp; You can modify the names for classes 
and properties by editing the dbml file.&nbsp; See
<a href="#Dbml.cst">Dbml.cst</a> for a list of safe attributes 
to change in the dbml file.</p>
<p>The template will generate 2 files for every Type in the dbml file.&nbsp; One 
file will be the generated partial class that can not be changed as it is overwritten 
when the template is re-ran.&nbsp; It will have the following file name... &lt;entity&gt;.Generated.cs</p>
<p>The second file is a partial class that can be modified as it will not be re-generated.&nbsp; 
You can implement the partial methods in this file.&nbsp; Some partial method stubs 
are created by default. This file will be named... &lt;entity&gt;.cs</p>
<p>If you set the project file property on the template, the generated files will 
be added to the project.&nbsp; The file that can not be modified will be hidden 
under the file that can be changed.</p>
<p>Properties on the Entities.cst template:</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the entities from.</td>
	</tr>
	<tr>
		<td>Framework</td>
		<td>The version of the .Net Framework that is being used.
		    Version 35_1 is necessary for dynamic data and data services attributes.</td>
	</tr>
	<tr>
		<td>IncludeDataContract</td>
		<td>Include serialization attributes on the generated entities. 
		    The attributes generated are based on the framework attribute above.</td>
	</tr>
	<tr>
		<td>IncludeDataServices</td>
		<td>Include Data Services attributes on the generated entities.</td>
	</tr>
	<tr>
		<td>OutputDirectory</td>
		<td>The folder to save the generated files.</td>
	</tr>
</table>
<h2><a title="Managers.cst" name="Managers.cst">Managers.cst Template</a></h2>
<p>The manager template is for helping you get started with business logic for the 
LINQ entities.&nbsp; The managers will have common queries that are created from 
keys and indexes on the table.&nbsp; The manager will also have rules for the entity 
properties to make sure required fields are not null and that the length of a string 
does not exceed the max length the column allows.</p>
<p>The template works by creating a second partial class that has a Manager 
property.&nbsp; The manager will then have a property for each entity that has a 
manager. Here is a sample of the syntax for using the managers:</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: #2b91af;">SampleDataContext </span>db = <span style="color: blue;">new</span> <span style="color: #2b91af;">SampleDataContext</span>();</p>
	<p style="margin: 0px;"><span style="color: green;">// use the primary key</span></p>
	<p style="margin: 0px;"><span style="color: #2b91af;">Task</span> task = db.Manager.Task.GetByKey(taskId);</p>
	<p style="margin: 0px;"><span style="color: green;">// use a foreign key</span></p>
	<p style="margin: 0px;"><span style="color: blue;">var</span> myTasks = db.Manager.Task.GetByAssignedID(userId);</p>
	<p style="margin: 0px;"><span style="color: green;">// the methods return IQueryable 
	so you can add expressions</span></p>
	<p style="margin: 0px;"><span style="color: blue;">var</span> openTasks = db.Manager.Task.GetByStatusID(statusId).OrderBy(t 
	=&gt; t.CreateDate);</p>
</div>
<p>The manager will add business rules to your entities based on metadata attributes.
These rules are based on the same rules found in the DataAnnotations.</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
<p style="margin: 0px;"><span style="color: blue;">private</span> 
<span style="color: blue;">class</span><span style="color: #2b91af;"> Metadata</span></p>
<p style="margin: 0px;">{</p>
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Only Attributes 
in the class will be preserved.</span></p>
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>            
<span style="color: blue;">int</span> OrderId { <span style="color: blue;">get</span>; 
<span style="color: blue;">set</span>; }</p>
<p></p>            
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Required</span>]</p>
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">StringLength</span>(20)]</p>
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
<span style="color: blue;">string</span> UserId { <span style="color: blue;">get</span>;
<span style="color: blue;">set</span>; }</p>
<p></p> 
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; [<span style="color: #2b91af;">Range</span>
(<span style="color: blue;">typeof</span>(<span style="color: #2b91af;">DateTime</span>),
<span style="color: #a31515;">&quot;10-31-2008&quot;</span>,
<span style="color: #a31515;">&quot;12-25-2200&quot;</span>)]</p>      
<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
System.<span style="color: #2b91af;">DateTime</span> OrderDate { 
<span style="color: blue;">get</span>; <span style="color: blue;">set</span>; }</p>
<p>.......</p>
<p style="margin: 0px;">}</p>
</div>

<p>The manager also provides a business rules engine to your entities. In addition 
to the default validation rules that are generated, you can add custom rules by 
implementing the AddRules partial method in the custom entity class.</p>
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: blue;">static</span>
	<span style="color: blue;">partial</span> <span style="color: blue;">void</span> 
	AddRules()</p>
	<p style="margin: 0px;">{</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	allows the Name property to be a max of 150 characters.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	LengthRule(<span style="color: #a31515;">&quot;Name&quot;</span>, 150));</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	that validates the value of the property using regex.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	RegexRule(<span style="color: #a31515;">&quot;Name&quot;</span>,
	<span style="color: #a31515;">&quot;.*&quot;</span>));</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: green;">// Rule 
	allows only users in certain security roles to update.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; RuleManager.AddShared&lt;<span style="color: #2b91af;">Task</span>&gt;(<span style="color: blue;">new</span> 
	UpdateRule(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">new</span> <span style="color: blue;">string</span>[] 
	{ <span style="color: #a31515;">&quot;Administrator&quot;</span>,
	<span style="color: #a31515;">&quot;Updaters&quot;</span> }));</p>
	<p style="margin: 0px;">}</p>
</div>
<p>Properties on the Managers.cst template:</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to keys and indexes from for generating the manager 
		classes.</td>
	</tr>
	<tr>
		<td>Framework</td>
		<td>The version of the .Net Framework that is being used.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the manager classes from.</td>
	</tr>
	<tr>
		<td>DataContextFile</td>
		<td>The location of the DataContext File.</td>
	</tr>
	<tr>
		<td>DataContextName</td>
		<td>The class name of the DataContext that supports the managers.</td>
	</tr>
	<tr>
		<td>ManagerDirectory</td>
		<td>The folder to save the generated manager files.</td>
	</tr>
	<tr>
		<td>ManagerNamespace</td>
		<td>The namespace to use for the generated manager class files.</td>
	</tr>
</table>
<h2><a name="Queries.cst_Template">Queries.cst Template</a></h2>
<p>The queries template is an optional alternative to the manager template.&nbsp; 
If you don&#39;t want to use the manager framework, you can use this template to 
generate some common queries for an entity.&nbsp; While its possible to use both 
the manger and query templates, they do duplicate some functionality. The 
template works by generating an extension class for Table&lt;Entity&gt;.&nbsp; This 
allows the queries to be off the DataContext.</p>
<!--
{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Consolas;}}{\colortbl;??\red43\green145\blue175;\red255\green255\blue255;\red0\green0\blue0;\red0\green0\blue255;}??\fs20 \cf1 SampleDataContext\cf0  db = \cf4 new\cf0  \cf1 SampleDataContext\cf0 ();\par ??\cf1 Task\cf0  task = db.Task.GetByID(1);\par ??}
-->
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: #2b91af;">SampleDataContext</span> 
	db = <span style="color: blue;">new</span> <span style="color: #2b91af;">
	SampleDataContext</span>();</p>
	<p style="margin: 0px;"><span style="color: #2b91af;">Task</span> task = 
	db.Task.GetByKey(1);</p>
</div>
<!--EndFragment-->
<p>This is an example of what the extension class looks like.</p>
<!--
{\rtf1\ansi\ansicpg\lang1024\noproof1252\uc1 \deff0{\fonttbl{\f0\fnil\fcharset0\fprq1 Consolas;}}{\colortbl;??\red128\green128\blue128;\red255\green255\blue255;\red0\green128\blue0;\red0\green0\blue255;\red0\green0\blue0;\red43\green145\blue175;}??\fs20 \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??///\cf3  The query extension class for Task.\par ??\cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf4 public\cf0  \cf4 static\cf0  \cf4 partial\cf0  \cf4 class\cf0  \cf6 TaskQueryExtension\par ??\cf0 \{\par ??    \par ??    \par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets an instance by the primary key.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 Task\cf0  GetByTaskID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  taskID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByTaskID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, taskID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.FirstOrDefault(t =&gt; t.TaskID == taskID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByStatusID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  statusID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByStatusID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, statusID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.StatusID == statusID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByPriorityID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  priorityID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByPriorityID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, priorityID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.PriorityID == priorityID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByCreatedID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  createdID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByCreatedID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, createdID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.CreatedID == createdID);\par ??    \}\par ??\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  Gets a query by an index.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 public\cf0  \cf4 static\cf0  \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt; GetByAssignedID(\cf4 this\cf0  \cf6 Table\cf0 &lt;\cf6 Task\cf0 &gt; entity, \cf4 int\cf0  assignedID)\par ??    \{\par ??        \cf4 if\cf0  (entity.Context.LoadOptions == \cf4 null\cf0 ) \par ??            \cf4 return\cf0  \cf6 Query\cf0 .GetByAssignedID.Invoke((\cf6 SampleDataContext\cf0 )entity.Context, assignedID);\par ??        \cf4 else\par ??\cf0             \cf4 return\cf0  entity.Where(t =&gt; t.AssignedID == assignedID);\par ??    \}\par ??\par ??\cf4     #region\cf0  Query\par ??    \cf1 ///\cf3  \cf1 &lt;summary&gt;\par ??\cf0     \cf1 ///\cf3  A private class for lazy loading static compiled queries.\par ??\cf0     \cf1 ///\cf3  \cf1 &lt;/summary&gt;\par ??\cf0     \cf4 private\cf0  \cf4 static\cf0  \cf4 partial\cf0  \cf4 class\cf0  \cf6 Query\par ??\cf0     \{\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 Task\cf0 &gt; GetByTaskID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  taskID) =&gt; \par ??                    db.Task.FirstOrDefault(t =&gt; t.TaskID == taskID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByStatusID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  statusID) =&gt; \par ??                    db.Task.Where(t =&gt; t.StatusID == statusID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByPriorityID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  priorityID) =&gt; \par ??                    db.Task.Where(t =&gt; t.PriorityID == priorityID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByCreatedID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  createdID) =&gt; \par ??                    db.Task.Where(t =&gt; t.CreatedID == createdID));\par ??\par ??        \cf4 internal\cf0  \cf4 static\cf0  \cf4 readonly\cf0  \cf6 Func\cf0 &lt;\cf6 SampleDataContext\cf0 , \cf4 int\cf0 , \cf6 IQueryable\cf0 &lt;\cf6 Task\cf0 &gt;&gt; GetByAssignedID = \par ??            \cf6 CompiledQuery\cf0 .Compile(\par ??                (\cf6 SampleDataContext\cf0  db, \cf4 int\cf0  assignedID) =&gt; \par ??                    db.Task.Where(t =&gt; t.AssignedID == assignedID));\par ??\par ??    \}\par ??\cf4     #endregion\par ??\cf0 \}\par ??}
-->
<div style="font-family: Courier New; font-size: 10pt; color: black; background: white;">
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;"> 
	The query extension class for Task.</span></p>
	<p style="margin: 0px;"><span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;"><span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: blue;">partial</span>
	<span style="color: blue;">class</span> <span style="color: #2b91af;">
	TaskQueryExtension</span></p>
	<p style="margin: 0px;">{</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	Gets an instance by the primary key.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: #2b91af;">Task</span> 
	GetByKey(<span style="color: blue;">this</span>
	<span style="color: #2b91af;">Table</span>&lt;<span style="color: #2b91af;">Task</span>&gt; 
	entity, <span style="color: blue;">int</span> taskID)</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">if</span> (entity.Context.LoadOptions ==
	<span style="color: blue;">null</span>) </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> <span style="color: #2b91af;">Query</span>.GetByKey.Invoke((<span style="color: #2b91af;">SampleDataContext</span>)entity.Context, 
	taskID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">else</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> entity.FirstOrDefault(t =&gt; t.TaskID 
	== taskID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	Gets a query by an index.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">public</span>
	<span style="color: blue;">static</span> <span style="color: #2b91af;">
	IQueryable</span>&lt;<span style="color: #2b91af;">Task</span>&gt; GetByStatusID(<span style="color: blue;">this</span>
	<span style="color: #2b91af;">Table</span>&lt;<span style="color: #2b91af;">Task</span>&gt; 
	entity, <span style="color: blue;">int</span> statusID)</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">if</span> (entity.Context.LoadOptions ==
	<span style="color: blue;">null</span>) </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> <span style="color: #2b91af;">Query</span>.GetByStatusID.Invoke((<span style="color: #2b91af;">SampleDataContext</span>)entity.Context, 
	statusID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">else</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">return</span> entity.Where(t =&gt; t.StatusID == 
	statusID);</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;"><span style="color: blue;">&nbsp;&nbsp;&nbsp; 
	#region</span> Query</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;"> 
	A private class for lazy loading static compiled queries.</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: gray;">///</span><span style="color: green;">
	</span><span style="color: gray;">&lt;/summary&gt;</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; <span style="color: blue;">
	private</span> <span style="color: blue;">static</span>
	<span style="color: blue;">partial</span> <span style="color: blue;">class</span>
	<span style="color: #2b91af;">Query</span></p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; {</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">internal</span> <span style="color: blue;">static</span>
	<span style="color: blue;">readonly</span> <span style="color: #2b91af;">
	Func</span>&lt;<span style="color: #2b91af;">SampleDataContext</span>,
	<span style="color: blue;">int</span>, <span style="color: #2b91af;">Task</span>&gt; 
	GetByKey = </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: #2b91af;">CompiledQuery</span>.Compile(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	(<span style="color: #2b91af;">SampleDataContext</span> db,
	<span style="color: blue;">int</span> taskID) =&gt; </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	db.Task.FirstOrDefault(t =&gt; t.TaskID == taskID));</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: blue;">internal</span> <span style="color: blue;">static</span>
	<span style="color: blue;">readonly</span> <span style="color: #2b91af;">
	Func</span>&lt;<span style="color: #2b91af;">SampleDataContext</span>,
	<span style="color: blue;">int</span>, <span style="color: #2b91af;">
	IQueryable</span>&lt;<span style="color: #2b91af;">Task</span>&gt;&gt; GetByStatusID 
	= </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<span style="color: #2b91af;">CompiledQuery</span>.Compile(</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	(<span style="color: #2b91af;">SampleDataContext</span> db,
	<span style="color: blue;">int</span> statusID) =&gt; </p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
	db.Task.Where(t =&gt; t.StatusID == statusID));</p>
	<p style="margin: 0px;">&nbsp;</p>
	<p style="margin: 0px;">&nbsp;&nbsp;&nbsp; }</p>
	<p style="margin: 0px;"><span style="color: blue;">&nbsp;&nbsp;&nbsp; #endregion</span></p>
	<p style="margin: 0px;">}</p>
</div>
<!--EndFragment-->
<p>Properties on the Queries.cst template:</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>SourceDatabase</td>
		<td>The source database to keys and indexes from for generating the manager 
		classes.</td>
	</tr>
	<tr>
		<td>DbmlFile</td>
		<td>The path to the dbml file used generate the query classes from.</td>
	</tr>
	<tr>
		<td>QueryDirectory</td>
		<td>The folder to save the generated query extension files.</td>
	</tr>
	<tr>
		<td>ProjectFile</td>
		<td>The Visual Studio project file to add the generated files to.</td>
	</tr>
</table>
<h2><a name="Global.cs_Template">Global.cst Template</a></h2>
<p>The global templat is for use specifically with dynamic data projects.&nbsp; It
can be used to generate the global.asax file with the appropriate Data Context and
routing.</p>
<table cellpadding="4">
	<tr>
		<th>Property</th>
		<th>Description</th>
	</tr>
	<tr>
		<td>ClassNamespace</td>
		<td>The namespace for the project.</td>
	</tr>
	<tr>
		<td>ContextNamespace</td>
		<td>The namespace of the datacontext.</td>
	</tr>
	<tr>
		<td>DataContextName</td>
		<td>The name of the data context class.</td>
	</tr>
	<tr>
		<td>InlineEditing</td>
		<td>Default the routing to allow inline editing of tables.</td>
	</tr>
</table>
<h2><a title="KnownIssues" name="KnownIssues"></a>Known Issues</h2>
<ul>
	<li>The generated DataContext does not set the connection string like the LINQ 
	to SQL designer</li>
</ul>
<h2><a title="Roadmap" name="Roadmap"></a>Roadmap</h2>
<ul>
	<li>Unit test generation</li>
	<li>Web service generation</li>
	<li>ASP.NET, Winforms and WPF UI generation</li>
</ul>
<h2><a name="Download"></a>Download</h2>
<p>Download the latest release of PLINQO.</p>
<ul>
	<li><a href="http://code.google.com/p/codesmith/downloads/list">Latest Release</a></li>
	<li><a href="http://community.codesmithtools.com/nightly/plinqo/">Nightly Builds</a></li>
</ul>
<h2>History</h2>
<ul>
	<li>Release 5.0.1<ul>
		<li>added IncludeList property</li>
		<li>fix keyword escapes to functions</li>
		<li>add Serializable attribute</li>
		<li>add QueryNamespace property</li>
		<li>make enums use full namespace</li>
		<li>fix issue with &quot;An item with the same key has already been added.&quot;</li>
		<li>apply patch for ByRef params in vb functions</li>
		<li>fix issue for cache on different databases</li>
		<li>fix include list preventing association generation</li>
		<li>fix default profile bug</li>
		<li>make IsPrimaryKey update</li>
		<li>fix initializing PLINQO rules asynchronously fails</li>
	</ul>
	</li>
	<li>Release 5.0
	<ul>
		<li>Added Visual Studio 2010 and .NET 4 Support</li>
		<li>Updated QuickStart with latest Dynamic Data and DataServices</li>
		<li>Added SQLCacheDependancy Support</li>
		<li>Added IQueryable Cache Extensions</li>
		<li>Added Include extension for advanced eager loading </li>
		<li>Improved AuditLog, now includes updates after SubmitChanges</li>
		<li>Fixed bug in CacheManager where default profile did not load properly</li>
		<li>Added override RuleManager.Run override that populates the TrackedObject.Original</li>
		<li>Fixed bug in AuditLog</li>
		<li>Fixed bugs in VB Quick Start</li>
		<li>Added DataContextName to QuickStart.cst</li>
		<li>Fixed Managers didn't have the same access modifier as entities</li>
		<li>Fixed bug in GetByKey function in VB</li>
		<li>Fixed invalid cast exception for Range attribute on short properties</li>
		<li>Fixed bug in ExecuteFutureQueries when no queries were loaded</li>
		<li>Fixed bug in Manager when column didn't exist </li>
		<li>Added logic to skip columns of type 'hierarchyid'</li>
		<li>Added work around for L2S Profiler not working with transactions</li>
		<li>Fixed bug where Metadata property types did not match up with Enums</li>
		<li>Added BeginTransaction with no overload</li>
	</ul>
	</li>
	<li>Release 4.0.1
	<ul>
		<li class="style1">Change to argument order of operators to make it more 
		clear which is the left and right side of the operation</li>
		<li>Add NextPage, PreviousPage, GotPage to PagedList</li>
		<li>Update CodeSmith.Data.chm to have correct email address for suppor</li>
		<li>Add methods GetOrSet to CacheManager and CacheProvider</li>
		<li>Add BeginTransaction to DataContextExtensions</li>
		<li>Add GeneratedCodeAttribute to Generated classes</li>
		<li>Fix issue with duplicate many to many names</li>
		<li>Add full namespace to Metadata class</li>
		<li>Fix bug in LinqCacheDataSource</li>
		<li>Add DataContextName to dbml template and Generator</li>
		<li>Change default Clean Expression to be less aggressive </li>
		<li>Added Current and Original entities to AuditEntity.</li>
		<li>&nbsp;Fixed a bug loading NRefactory causing the templates not to compile</li>
		<li>Add NotNull Rule and Attribute.</li>
		<li>Fix bug with Update and TimeSpan data type.</li>
		<li>Fix issue with column named &quot;Key&quot;</li>
		<li>Change ViewDirectory to ModelDirectory</li>
		<li>Change comments in Entity.Editable.cst</li>
		<li>Fix ToBinary</li>
		<li>Improve sql generated with null valuese</li>
	</ul>
	</li>
	<li>Release 4.0
		<ul>
			<li>Added future query support similar to NHibernate Futures
			<li>Added ability to query by null to query extensions
			<li>Added ability to query by a list of values to query extensions
			<li>Added ability to query using comparison operators (ie. greater than, less than) to query extensions
			<li>Added cache provider support
			<li>Added support for using Ayende's LINQ to SQL Profiler
			<li>Added Memcached cache provider
			<li>Added ability to create named cache profiles in configuration
			<li>Added ability to validate individual entities
			<li>Refactored RuleManager to lazy load shared rules
			<li>Combined extension method namespaces to make the extension methods more discoverable
			<li>Added support for SQL Server user defined functions
			<li>Added entity interfaces to help with mocking and other uses
			<li>Updated ToPagedList() to use future queries for retrieving the total row count
			<li>Added ToBinary(), FromBinary(), and FromXml() methods to help with entity serialization
			<li>Added UTC support for the Now attribute and rule
			<li>Added ClearCache() to remove queries from the cache
			<li>Fixed several bugs with batch queries
			<li>Many other bug fixes and small enhancements listed on the CodeSmith Google Code project site.
		</ul>
	</li>
	
	<li>Release 3.1<ul>
        <li>Added query result caching.</li>
        <li>Added a new AlwaysAuditAttribute to make it possible to always audit a property 
            even if it hasn&#39;t changed.</li>
        <li>Added partial change tracking methods for EntityRef associations.</li>
        <li>Added support for maintaining user defined associations.</li>
        <li>Added partial change tracking methods for EntityRef associations.</li>
        <li>Added shared version information for Assemblies.</li>
        <li>Added support for AuditPropertyFormat.</li>
        <li>Removed AddRule that is no longer used in manager templates.</li>
        <li>Updated manager templates classes to lazy load.</li>
        <li>Fixed many to many issue when IncludeDeleteOnNull is false.</li>
        <li>Fixed&nbsp;bug with a keyword in function parameter name.</li>
        <li>Fixed&nbsp;bug with transactions in ExecuteQuery.</li>
        <li>Fixed&nbsp;bug with nullable columns in queries.</li>
        <li>Fixed&nbsp;bug with nullable parameter in query.</li>
        <li>Fixed&nbsp;support for inheritance.</li>
        </ul>
    </li>
    <li>Release 3.0<ul>
        <li>Added Entity Detach.</li>
        <li>Added Entity Clone.</li>
        <li>Added support for Many-to-Many Relationships.</li>
        <li>Added auditing.</li>
        <li>Added Batch Updates and Deletes.</li>
        <li>Added support for multiple result sets.</li>
        </ul>
    </li>
    <li>Release 2.x<ul>
        <li>Added Enum table support.</li>
        <li>Added Many To Many association support.</li>
        <li>Added Detach method to Context.</li>
        <li>Added ICloneable on Business Entities.</li>
        <li>Updated Insert Class Merge Strategy to support merging Namespaces.</li>
        <li>Fix Issue with DeleteOnNull persisting when IncludeDeleteOnNull set to False.</li>
    </ul>
    </li>
    <li>Release 2.0<ul>
        <li>Added Quickstart template to allow quick generation of a Plinqo based 
        web project.</li>
        <li>Added various Naming Convention properties to give better control
        over object naming standards. </li>
        <li>Added Dynamic Data support to generated entities.</li>
        <li>Added Metadata Internal class.</li>
        <li>LinqEntityBase now has an editable parent file.</li>
        <li>Manager produces rules based on MetaData Attributes</li>
        <li>Added Global.asax Template</li>
        <li>Entity Serialization adds functionality based on .Net framework version.</li>
        <li>Added Data Services support.</li>
    </ul>
    </li>
	<li>Release 1.3<ul>
		<li>added GetByKey(IEntityKey) common method for manager template</li>
		<li>made managers inherit from base classes in manager template</li>
		<li class="style1">made primary key query use common name GetByKey in 
		manager and query templates</li>
		<li>fix namespace issues when context and entity namespaces aren&#39;t the 
		same</li>
		<li>fix QueryExtension with wrong context name</li>
		<li>fix CompiledQuery issue when there are more then four columns</li>
		<li>fix issue with compiled queries and load options</li>
		<li>fix bugs when dbml file is loaded in designer </li>
		<li>add support for adding the ConnectionString to the settings file
		</li>
		<li>added Queries.cst to support query extension Methods </li>
		<li class="style1">&nbsp;removed manager data context, now another 
		partial of the DataContext</li>
		<li>added support for unique indexes</li>
		<li>added range rule for dates</li>
		<li>update to .net 3.5 RTM</li>
	</ul>
	</li>
	<li>Release 1.2<ul>
		<li>Fix LinqDataSource issue by making all properties writable</li>
		<li>Added CompiledQuery support to the manager classes</li>
		<li>Added support for overriding the column data type </li>
	</ul>
	</li>
	<li>Release 1.1<ul>
		<li>Changed to use dbml schema as meta data</li>
		<li>Split templates up to allow more flexibility</li>
		<li>Added function, table inheritance, ignoring, and name cleaning 
		support</li>
	</ul>
	</li>
</ul>

<p>&nbsp;</p>

<p class="style1">*Breaking change</p>

</body>

</html>
